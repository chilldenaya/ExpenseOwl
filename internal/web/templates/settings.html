<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/fa.min.css">
    <link rel="stylesheet" href="/style.css">
    <script>
        (function() {
            const theme = localStorage.getItem('theme') || 'system';
            if (theme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            } else if (theme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        })();
    </script>
    <title>ExpenseOwl Settings</title>
</head>
<body>
    <div class="container">
        <header>
            <div class="nav-bar">
                <a href="/">
                    <img src="/pwa/icon-192.png" alt="ExpenseOwl Logo" height="85" style="vertical-align: middle; margin-right: 20px;">
                </a>
                <a href="/" class="view-button" data-tooltip="Dashboard">
                    <i class="fa-solid fa-chart-pie"></i>
                </a>
                <a href="/table" class="view-button" data-tooltip="Table View">
                    <i class="fa-solid fa-table"></i>
                </a>
                <a href="/investment" class="view-button" data-tooltip="Assets">
                    <i class="fa-solid fa-coins"></i>
                </a>
                <a href="/settings" class="view-button active" data-tooltip="Settings">
                    <i class="fa-solid fa-gear"></i>
                </a>
            </div>
        </header>

        <div class="settings-section">
            <h2 class="settings-section-title">Categories & Organization</h2>
            <div class="settings-container">
                <div class="form-container half-width">
                    <h3 align="center">Expense Categories</h3>
                    <div id="categories-manager">
                        <div id="categories-list" class="categories-list"></div>
                        <div class="category-input-container">
                            <input type="text" id="newCategory" placeholder="Add new category">
                            <button id="addCategory" class="nav-button">Add</button>
                        </div>
                        <button id="saveCategories" class="nav-button">Save Categories</button>
                        <div id="categoriesMessage" class="form-message"></div>
                    </div>
                </div>
                <div class="form-container half-width">
                    <h3 align="center">Asset Types</h3>
                    <div id="investment-types-manager">
                        <p class="settings-hint">Types used for asset transactions (e.g. Index, Crypto, ETF, Bonds).</p>
                        <div id="investment-types-list" class="categories-list"></div>
                        <div class="category-input-container">
                            <input type="text" id="newInvestmentType" placeholder="Add new asset type">
                            <button id="addInvestmentType" class="nav-button">Add</button>
                        </div>
                        <button id="saveInvestmentTypes" class="nav-button">Save Asset Types</button>
                        <div id="investmentTypesMessage" class="form-message"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h2 class="settings-section-title">Preferences</h2>
            <div class="settings-container three-col">
                <div class="form-container">
                    <h3 align="center">Currency</h3>
                    <div class="currency-selector">
                        <select id="currencySelect"></select>
                        <button id="saveCurrency" class="nav-button">Save</button>
                    </div>
                    <div id="currencyMessage" class="form-message"></div>
                </div>
                <div class="form-container">
                    <h3 align="center">Start Date</h3>
                    <div class="start-date-manager">
                        <input type="number" id="startDate" min="1" max="31" placeholder="1">
                        <button id="saveStartDate" class="nav-button">Save</button>
                    </div>
                    <div id="startDateMessage" class="form-message"></div>
                </div>
                <div class="form-container">
                    <h3 align="center">Theme</h3>
                    <div class="theme-selector">
                        <select id="themeSelect">
                            <option value="system">System Default</option>
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                        </select>
                    </div>
                    <div id="themeMessage" class="form-message"></div>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h2 class="settings-section-title">Budgets</h2>
            <div class="form-container">
                <div class="budget-section">
                    <h3 align="center">Monthly Budgets</h3>
                    <p class="settings-hint">Set monthly budgets for each category. Budgets reset automatically each month.</p>
                    
                    <div class="budget-overall">
                        <label for="overallBudget">Overall Budget (Total)</label>
                        <div class="budget-input-row">
                            <span class="currency-symbol" id="budgetCurrencySymbol">$</span>
                            <input type="number" id="overallBudget" step="0.01" min="0" placeholder="0.00">
                        </div>
                    </div>

                    <div id="category-budgets">
                        <!-- Category budgets will be dynamically added here -->
                    </div>

                    <button id="saveBudgets" class="btn btn-primary" style="margin-top: 1rem;">Save Budgets</button>
                    <div id="budgetsMessage" class="form-message"></div>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h2 class="settings-section-title">Data Management</h2>
            <div class="form-container">
                <div class="export-buttons">
                    <div class="export-options">
                        <a href="/export/csv" id="csv-export-file" class="nav-button" download="expenses.csv">Export to CSV</a>
                    </div>
                    <div class="import-option">
                        <label for="csv-import-file" class="nav-button">Import from CSV</label>
                        <input type="file" id="csv-import-file" accept=".csv" style="display: none;">
                    </div>
                    <div class="import-option">
                        <label for="csv-import-file-old" class="nav-button">Import from ExpenseOwl v3.20-</label>
                        <input type="file" id="csv-import-file-old" accept=".csv" style="display: none;">
                    </div>
                </div>
                <div id="importMessage" class="form-message"></div>
                <div id="importSummary" class="import-summary" style="display: none;">
                    <h3>Import Summary</h3>
                    <p>Total Processed: <span id="summary-processed"></span></p>
                    <p>Imported: <span id="summary-imported"></span></p>
                    <p>Skipped: <span id="summary-skipped"></span></p>
                    <p>New Categories: <span id="summary-new-categories"></span></p>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h2 class="settings-section-title">Automation</h2>
            <div class="table-controls-column">
                <button id="toggleRecurringFormBtn" class="btn btn-primary"><i class="fa-solid fa-plus"></i> Add Recurring Transaction</button>
            </div>
            <div id="addRecurringContainer" style="display: none;">
                <div class="form-container">
                    <form id="recurringExpenseForm" class="expense-form recurring-expense-form">
                <div class="form-group">
                    <label for="recurringName">Name</label>
                    <input type="text" id="recurringName" required>
                </div>
                <div class="form-group">
                    <label for="recurringAmount">Amount</label>
                    <input type="number" id="recurringAmount" step="0.01" min="0.01" max="9000000000000000" required>
                </div>
                <div class="form-group">
                    <label for="recurringCategory">Category</label>
                    <select id="recurringCategory" required></select>
                </div>
                <div class="form-group">
                    <label for="tags-input">Tags</label>
                    <div class="tags-input-container">
                        <div id="selected-tags" class="selected-tags"></div>
                        <input type="text" id="tags-input" placeholder="(optional)">
                    </div>
                    <div id="tags-dropdown" class="tags-dropdown"></div>
                </div>
                <div class="form-group">
                    <label for="recurringInterval">Interval</label>
                    <select id="recurringInterval" required>
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <option value="monthly">Monthly</option>
                        <option value="yearly">Yearly</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="recurringStartDate">Start Date</label>
                    <input type="date" id="recurringStartDate" required>
                    <script>
                        const today = new Date();
                        const year = today.getFullYear();
                        const month = String(today.getMonth() + 1).padStart(2, '0');
                        const day = String(today.getDate()).padStart(2, '0');
                        const formattedDate = `${year}-${month}-${day}`;
                        document.getElementById('recurringStartDate').value = formattedDate;
                    </script>
                </div>
                <div class="form-group">
                    <label for="recurringOccurrences">Occurrences</label>
                    <input type="number" id="recurringOccurrences" min="2" value="2" required>
                </div>
                <div class="form-group form-group-submit">
                    <button type="submit" class="btn btn-primary">Add Recurring Transaction</button>
                </div>
                    </form>
                    <div id="recurringExpenseMessage" class="form-message"></div>
                </div>
            </div>
            <h3 align="center" style="margin-top: 2rem;">Existing Recurring Transactions</h3>
            <div id="recurring-expenses-list"></div>
        </div>
    </div>

    <div id="deleteRecurringModal" class="modal">
        <div class="modal-content">
            <h3>Delete Recurring Expense</h3>
            <p>Do you want to delete all instances of this expense, or only future ones?</p>
            <div class="modal-buttons">
                <button class="modal-button" onclick="closeRecurringDeleteModal()">Cancel</button>
                <button class="modal-button" onclick="confirmRecurringDelete(false)">Delete Future</button>
                <button class="modal-button confirm" onclick="confirmRecurringDelete(true)">Delete All</button>
            </div>
        </div>
    </div>

    <div id="editRecurringModal" class="modal">
        <div class="modal-content">
            <h3>Edit Recurring Expense</h3>
            <form id="editRecurringExpenseForm" class="expense-form recurring-expense-form">
                 <div class="form-group">
                    <label for="editRecurringName">Name</label>
                    <input type="text" id="editRecurringName" required>
                </div>
                <div class="form-group">
                    <label for="editRecurringAmount">Amount</label>
                    <input type="number" id="editRecurringAmount" step="0.01" min="0" required>
                </div>
                <div class="form-group">
                    <label for="editRecurringCategory">Category</label>
                    <select id="editRecurringCategory" required></select>
                </div>
                <div class="form-group">
                    <label for="edit-tags-input">Tags</label>
                    <div class="tags-input-container">
                        <div id="edit-selected-tags" class="selected-tags"></div>
                        <input type="text" id="edit-tags-input" placeholder="(optional)">
                    </div>
                    <div id="edit-tags-dropdown" class="tags-dropdown"></div>
                </div>
                <div class="form-group">
                    <label for="editRecurringInterval">Interval</label>
                    <select id="editRecurringInterval" required>
                        <option value="daily">Daily</option>
                        <option value="weekly">Weekly</option>
                        <option value="monthly">Monthly</option>
                        <option value="yearly">Yearly</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="editRecurringStartDate">Start Date</label>
                    <input type="date" id="editRecurringStartDate" required>
                </div>
                <div class="form-group">
                    <label for="editRecurringOccurrences">Occurrences (0 for indefinite)</label>
                    <input type="number" id="editRecurringOccurrences" min="0" value="0" required>
                </div>
            </form>
            <div class="modal-buttons">
                <button class="modal-button" onclick="closeRecurringEditModal()">Cancel</button>
                <button class="modal-button" onclick="confirmRecurringUpdate(false)">Update Future</button>
                <button class="modal-button confirm" onclick="confirmRecurringUpdate(true)">Update All</button>
            </div>
        </div>
    </div>

    <footer class="page-footer">
        <div class="footer-content">
            <span>Version: <a href="https://github.com/tanq16/expenseowl/releases/latest" target="_blank" rel="noopener noreferrer">v4.0</a></span>
            <span class="footer-separator">|</span>
            <a href="https://github.com/tanq16/expenseowl/blob/main/README.md" target="_blank" rel="noopener noreferrer">Documentation</a>
            <span class="footer-separator">|</span>
            <a href="https://github.com/tanq16/expenseowl" target="_blank" rel="noopener noreferrer">GitHub</a>
        </div>
    </footer>

    <script src="/functions.js"></script>
    <script>
        let categories = [];
        let investmentTypes = [];
        let allTags = new Set();
        let addFormSelectedTags = new Set();
        let editFormSelectedTags = new Set();
        let currentCurrency = "usd";
        let currentStartDate = 1;
        let draggedItem = null;
        let recurringExpenses = [];
        let recurringExpenseToDelete = null;
        let recurringExpenseToEdit = null;
        let budgets = [];
        let expenseCategories = [];

        function showMessage(elementId, message, isSuccess) {
            const messageDiv = document.getElementById(elementId);
            messageDiv.textContent = message;
            messageDiv.className = isSuccess ? 'form-message success' : 'form-message error';
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = 'form-message';
            }, 3000);
        }

        const LOCKED_CATEGORIES = ['Income', 'Investment'];

        // --- Category Management ---
        function renderCategories() {
            const list = document.getElementById('categories-list');
            list.innerHTML = '';
            categories.forEach((category, index) => {
                const isLocked = LOCKED_CATEGORIES.includes(category);
                const item = document.createElement('div');
                item.className = 'category-item' + (isLocked ? ' locked' : '');
                item.draggable = true;
                item.dataset.index = index;
                item.innerHTML = `
                    <div class="category-handle-area">
                        <span class="drag-handle"><i class="fa-solid fa-grip-lines"></i></span>
                        <span>${category}</span>
                        ${isLocked ? '<span class="locked-badge"><i class="fa-solid fa-lock"></i></span>' : ''}
                    </div>
                    ${isLocked ? '' : `<button class="delete-button" onclick="removeCategory(${index})">
                        <i class="fa-solid fa-times"></i>
                    </button>`}
                `;
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('drop', handleDrop);
                list.appendChild(item);
            });
        }

        function handleDragStart(e) {
            this.classList.add('dragging');
            draggedItem = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            removePlaceholders();
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            this.classList.add('drag-over');
            if (this === draggedItem) return false;
            const rect = this.getBoundingClientRect();
            const clientY = e.clientY;
            const threshold = rect.top + (rect.height / 2);
            const isBefore = clientY < threshold;
            removePlaceholders();
            const placeholder = document.createElement('div');
            placeholder.className = 'placeholder';
            if (isBefore) {
                this.parentNode.insertBefore(placeholder, this);
            } else {
                this.parentNode.insertBefore(placeholder, this.nextSibling);
            }
            return false;
        }

        function handleDragLeave() { this.classList.remove('drag-over'); }
        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.category-item, .tag-item').forEach(item => item.classList.remove('drag-over'));
            removePlaceholders();
        }
        function removePlaceholders() { document.querySelectorAll('.placeholder').forEach(p => p.remove()); }

        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            removePlaceholders();
            if (draggedItem !== this) {
                const fromIndex = parseInt(draggedItem.dataset.index, 10);
                let toIndex = parseInt(this.dataset.index, 10);
                const rect = this.getBoundingClientRect();
                const isBefore = e.clientY < rect.top + rect.height / 2;
                if (!isBefore) toIndex++;
                if (fromIndex < toIndex) toIndex--;
                const list = categories;
                const movedItem = list.splice(fromIndex, 1)[0];
                list.splice(toIndex, 0, movedItem);
                renderCategories();
            }
            return false;
        }

        function addCategory() {
            const input = document.getElementById('newCategory');
            let category = input.value.trim();
            category = category.replace(/[<>]/g, ' ').trim();
            if (LOCKED_CATEGORIES.includes(category)) {
                showMessage('categoriesMessage', `"${category}" is a reserved category name`, false);
                return;
            }
            if (category && !categories.includes(category)) {
                categories.push(category);
                renderCategories();
                input.value = '';
            } else if (categories.includes(category)) {
                showMessage('categoriesMessage', 'Category already exists', false);
            } else if (!category) {
                showMessage('categoriesMessage', 'Category name cannot be empty.', false);
            }
        }

        function removeCategory(index) {
            const category = categories[index];
            if (LOCKED_CATEGORIES.includes(category)) {
                showMessage('categoriesMessage', `"${category}" category cannot be removed`, false);
                return;
            }
            categories.splice(index, 1);
            renderCategories();
        }

        async function saveCategories() {
            if (categories.length === 0) {
                showMessage('categoriesMessage', 'At least one category is required', false);
                return;
            }
            try {
                const response = await fetch('/categories/edit', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(categories)
                });   
                if (response.ok) {
                    showMessage('categoriesMessage', 'Categories saved successfully', true);
                } else {
                    const error = await response.json();
                    showMessage('categoriesMessage', `Failed to save categories: ${error.error}`, false);
                }
            } catch (error) {
                console.error('Error saving categories:', error);
                showMessage('categoriesMessage', 'Error saving categories', false);
            }
        }

        // --- Investment Types Management ---
        function renderInvestmentTypes() {
            const list = document.getElementById('investment-types-list');
            list.innerHTML = '';
            investmentTypes.forEach((typeName, index) => {
                const item = document.createElement('div');
                item.className = 'category-item';
                item.innerHTML = `
                    <div class="category-handle-area">
                        <span>${typeName.replace(/[<>]/g, ' ')}</span>
                    </div>
                    <button class="delete-button" onclick="removeInvestmentType(${index})">
                        <i class="fa-solid fa-times"></i>
                    </button>
                `;
                list.appendChild(item);
            });
        }

        function addInvestmentType() {
            const input = document.getElementById('newInvestmentType');
            let typeName = input.value.trim().replace(/[<>]/g, ' ').trim();
            if (typeName && !investmentTypes.includes(typeName)) {
                investmentTypes.push(typeName);
                renderInvestmentTypes();
                input.value = '';
            } else if (investmentTypes.includes(typeName)) {
                showMessage('investmentTypesMessage', 'Type already exists', false);
            } else {
                showMessage('investmentTypesMessage', 'Type name cannot be empty.', false);
            }
        }

        function removeInvestmentType(index) {
            investmentTypes.splice(index, 1);
            renderInvestmentTypes();
        }

        async function saveInvestmentTypes() {
            try {
                const response = await fetch('/investment-types/edit', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(investmentTypes)
                });
                if (response.ok) {
                    showMessage('investmentTypesMessage', 'Asset types saved successfully', true);
                } else {
                    const error = await response.json();
                    showMessage('investmentTypesMessage', `Failed to save: ${error.error}`, false);
                }
            } catch (error) {
                console.error('Error saving investment types:', error);
                showMessage('investmentTypesMessage', 'Error saving asset types', false);
            }
        }
        
        // --- Tag Input Component ---
        function createTagInput(inputId, selectedContainerId, dropdownId, selectedTagsSet) {
            const input = document.getElementById(inputId);
            const selectedContainer = document.getElementById(selectedContainerId);
            const dropdown = document.getElementById(dropdownId);

            const renderSelected = () => {
                selectedContainer.innerHTML = '';
                selectedTagsSet.forEach(tag => {
                    const pill = document.createElement('div');
                    pill.className = 'tag-pill';
                    pill.textContent = tag;
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-tag';
                    removeBtn.textContent = 'Ã—';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        selectedTagsSet.delete(tag);
                        renderSelected();
                    };
                    pill.appendChild(removeBtn);
                    selectedContainer.appendChild(pill);
                });
            };

            const addTag = (tag) => {
                tag = tag.trim().replace(/[<>]/g, ' ').trim();
                if (tag) {
                    selectedTagsSet.add(tag);
                    renderSelected();
                }
                input.value = '';
                dropdown.style.display = 'none';
            };
            
            input.addEventListener('focus', () => {
                const value = input.value.trim().toLowerCase();
                dropdown.innerHTML = '';
                const availableTags = [...allTags].filter(tag => !selectedTagsSet.has(tag));
                if (availableTags.length > 0) {
                    availableTags.forEach(tag => {
                        const item = document.createElement('div');
                        item.textContent = tag;
                        item.onclick = () => addTag(tag);
                        dropdown.appendChild(item);
                    });
                    dropdown.style.display = 'block';
                }
            });

            input.addEventListener('input', () => {
                const value = input.value.trim().toLowerCase();
                dropdown.innerHTML = '';
                const filteredTags = [...allTags].filter(tag => tag.toLowerCase().includes(value) && !selectedTagsSet.has(tag));

                if (value && ![...allTags].map(t => t.toLowerCase()).includes(value)) {
                    const newItem = document.createElement('div');
                    newItem.textContent = `+ Create "${input.value.trim()}"`;
                    newItem.className = 'new-tag';
                    newItem.onclick = () => addTag(input.value.trim());
                    dropdown.appendChild(newItem);
                }
                
                filteredTags.forEach(tag => {
                    const item = document.createElement('div');
                    item.textContent = tag;
                    item.onclick = () => addTag(tag);
                    dropdown.appendChild(item);
                });
                dropdown.style.display = dropdown.children.length > 0 ? 'block' : 'none';
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (input.value.trim()) addTag(input.value.trim());
                }
            });

            document.addEventListener('click', (e) => {
                const container = input.closest('.tags-input-container');
                if (container && !container.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });
            return { renderSelected };
        }

        // --- Currency & Start Date ---
        function populateCurrencySelect() {
            const select = document.getElementById('currencySelect');
            select.innerHTML = Object.keys(currencyBehaviors).map(code => 
                `<option value="${code}" ${code === currentCurrency ? 'selected' : ''}>
                    ${code.toUpperCase()} (${currencyBehaviors[code].symbol})
                </option>`
            ).join('');
        }
        
        async function saveCurrency() {
            const currencyCode = document.getElementById('currencySelect').value;
            try {
                const response = await fetch('/currency/edit', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currencyCode)
                });
                if (response.ok) {
                    showMessage('currencyMessage', 'Currency saved successfully', true);
                    currentCurrency = currencyCode;
                } else {
                    showMessage('currencyMessage', 'Failed to save currency', false);
                }
            } catch (error) {
                console.error('Error saving currency:', error);
                showMessage('currencyMessage', 'Error saving currency', false);
            }
        }

        function populateStartDateInput() {
            document.getElementById("startDate").value = currentStartDate;
        }

        async function saveStartDate() {
            const startDateValue = document.getElementById("startDate").value;
            try {
                const response = await fetch('/startdate/edit', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(parseInt(startDateValue, 10))
                });
                showMessage('startDateMessage', response.ok ? 'Start date saved successfully' : 'Failed to save start date', response.ok);
            } catch (error) {
                console.error('Error saving start date:', error);
                showMessage('startDateMessage', 'Error saving start date', false);
            }
        }
        
        async function fetchAndRenderRecurringExpenses() {
            try {
                const response = await fetch('/recurring-expenses');
                if (!response.ok) throw new Error('Failed to fetch recurring expenses');
                recurringExpenses = await response.json() || [];
                renderRecurringExpenses(recurringExpenses);
            } catch (error) {
                console.error('Error fetching recurring expenses:', error);
                document.getElementById('recurring-expenses-list').innerHTML = '<p>Error loading recurring expenses.</p>';
            }
        }

        function findNextOccurrence(r) {
            let nextDate = new Date(r.startDate);
            const today = new Date();
            if (nextDate >= today) return nextDate.toLocaleDateString();
            if (r.occurrences > 0) {
                let occurrencesCount = 0;
                while (nextDate < today) {
                    occurrencesCount++;
                    if (occurrencesCount >= r.occurrences) return 'Finished';
                    switch(r.interval) {
                        case 'daily': nextDate.setDate(nextDate.getDate() + 1); break;
                        case 'weekly': nextDate.setDate(nextDate.getDate() + 7); break;
                        case 'monthly': nextDate.setMonth(nextDate.getMonth() + 1); break;
                        case 'yearly': nextDate.setFullYear(nextDate.getFullYear() + 1); break;
                    }
                }
                return nextDate.toLocaleDateString();
            } else { // Indefinite
                 while (nextDate < today) {
                    switch(r.interval) {
                        case 'daily': nextDate.setDate(nextDate.getDate() + 1); break;
                        case 'weekly': nextDate.setDate(nextDate.getDate() + 7); break;
                        case 'monthly': nextDate.setMonth(nextDate.getMonth() + 1); break;
                        case 'yearly': nextDate.setFullYear(nextDate.getFullYear() + 1); break;
                    }
                }
                return nextDate.toLocaleDateString();
            }
        }

        function renderRecurringExpenses(recurring) {
            const list = document.getElementById('recurring-expenses-list');
            if (!recurring || recurring.length === 0) {
                list.innerHTML = '<p style="margin-left: 0.5rem;">No recurring expenses found.</p>';
                return;
            }
            list.innerHTML = `
                <table class="expense-table">
                    <thead><tr><th>Name</th><th>Amount</th><th>Category</th><th>Interval</th><th>Next Occurrence</th><th></th></tr></thead>
                    <tbody>
                        ${recurring.map(r => `
                            <tr>
                                <td>${r.name}</td>
                                <td>${formatCurrency(r.amount)}</td>
                                <td>${r.category}</td>
                                <td>${r.interval.charAt(0).toUpperCase() + r.interval.slice(1)}</td>
                                <td>${findNextOccurrence(r)}</td>
                                <td>
                                    <button class="edit-button" onclick="showRecurringEditModal('${r.id}')"><i class="fa-solid fa-pen-to-square"></i></button>
                                    <button class="delete-button" onclick="showRecurringDeleteModal('${r.id}')"><i class="fa-solid fa-trash-can"></i></button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>`;
        }

        function showRecurringDeleteModal(id) {
            recurringExpenseToDelete = id;
            document.getElementById('deleteRecurringModal').classList.add('active');
        }

        function closeRecurringDeleteModal() {
            recurringExpenseToDelete = null;
            document.getElementById('deleteRecurringModal').classList.remove('active');
        }

        async function confirmRecurringDelete(removeAll) {
            if (!recurringExpenseToDelete) return;
            try {
                const response = await fetch(`/recurring-expense/delete?id=${recurringExpenseToDelete}&removeAll=${removeAll}`, { method: 'DELETE' });
                if (!response.ok) throw new Error('Failed to delete recurring expense');
                showMessage('recurringExpenseMessage', 'Recurring expense deleted successfully', true);
                fetchAndRenderRecurringExpenses();
            } catch (error) {
                console.error('Error deleting recurring expense:', error);
                showMessage('recurringExpenseMessage', 'Failed to delete recurring expense', false);
            } finally {
                closeRecurringDeleteModal();
            }
        }
        
        function showRecurringEditModal(id) {
            recurringExpenseToEdit = recurringExpenses.find(r => r.id === id);
            if (!recurringExpenseToEdit) return;
            document.getElementById('editRecurringName').value = recurringExpenseToEdit.name;
            document.getElementById('editRecurringAmount').value = Math.abs(recurringExpenseToEdit.amount);
            document.getElementById('editRecurringCategory').value = recurringExpenseToEdit.category;
            document.getElementById('editRecurringInterval').value = recurringExpenseToEdit.interval;
            document.getElementById('editRecurringStartDate').value = new Date(recurringExpenseToEdit.startDate).toISOString().split('T')[0];
            document.getElementById('editRecurringOccurrences').value = recurringExpenseToEdit.occurrences;
            editFormSelectedTags = new Set(recurringExpenseToEdit.tags || []);
            createTagInput('edit-tags-input', 'edit-selected-tags', 'edit-tags-dropdown', editFormSelectedTags).renderSelected();
            document.getElementById('editRecurringModal').classList.add('active');
        }
        
        function closeRecurringEditModal() {
            recurringExpenseToEdit = null;
            document.getElementById('editRecurringModal').classList.remove('active');
        }

        async function confirmRecurringUpdate(updateAll) {
            if (!recurringExpenseToEdit) return;
            const category = document.getElementById('editRecurringCategory').value;
            const isIncome = category === 'Income';
            let amount = parseFloat(document.getElementById('editRecurringAmount').value);
            if (!isIncome) {
                amount *= -1;
            }

            const updatedData = {
                ...recurringExpenseToEdit,
                name: document.getElementById('editRecurringName').value,
                amount: amount,
                category: category,
                tags: Array.from(editFormSelectedTags),
                interval: document.getElementById('editRecurringInterval').value,
                startDate: new Date(document.getElementById('editRecurringStartDate').value).toISOString(),
                occurrences: parseInt(document.getElementById('editRecurringOccurrences').value, 10)
            };
            
            try {
                const response = await fetch(`/recurring-expense/edit?id=${recurringExpenseToEdit.id}&updateAll=${updateAll}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updatedData)
                });
                if (!response.ok) throw new Error('Failed to update recurring expense');
                showMessage('recurringExpenseMessage', 'Recurring expense updated successfully', true);
                fetchAndRenderRecurringExpenses();
            } catch(error) {
                console.error('Error updating recurring expense:', error);
                showMessage('recurringExpenseMessage', 'Failed to update recurring expense', false);
            } finally {
                closeRecurringEditModal();
            }
        }

        // --- Budget Management ---
        function renderBudgets() {
            const container = document.getElementById('category-budgets');
            container.innerHTML = '';
            
            // Filter out Income and Investment from categories for budget setting
            const expenseCats = categories.filter(c => !LOCKED_CATEGORIES.includes(c));
            
            expenseCats.forEach(cat => {
                const budget = budgets.find(b => b.category === cat);
                const budgetAmount = budget ? budget.amount : '';
                
                const div = document.createElement('div');
                div.className = 'budget-category-row';
                div.innerHTML = `
                    <label>${cat}</label>
                    <div class="budget-input-row">
                        <span class="currency-symbol">$</span>
                        <input type="number" class="category-budget-input" data-category="${cat}" step="0.01" min="0" placeholder="0.00" value="${budgetAmount}">
                    </div>
                `;
                container.appendChild(div);
            });
            
            // Set overall budget
            const overallBudget = budgets.find(b => b.category === '');
            document.getElementById('overallBudget').value = overallBudget ? overallBudget.amount : '';
        }

        async function saveBudgets() {
            const budgetData = [];
            
            // Get overall budget
            const overallAmount = parseFloat(document.getElementById('overallBudget').value);
            if (!isNaN(overallAmount) && overallAmount > 0) {
                budgetData.push({ category: '', amount: overallAmount });
            }
            
            // Get category budgets
            const categoryInputs = document.querySelectorAll('.category-budget-input');
            categoryInputs.forEach(input => {
                const amount = parseFloat(input.value);
                if (!isNaN(amount) && amount > 0) {
                    budgetData.push({ category: input.dataset.category, amount: amount });
                }
            });
            
            try {
                const response = await fetch('/budgets/edit', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(budgetData)
                });
                if (!response.ok) throw new Error('Failed to save budgets');
                budgets = budgetData;
                showMessage('budgetsMessage', 'Budgets saved successfully!', true);
            } catch (error) {
                console.error('Error saving budgets:', error);
                showMessage('budgetsMessage', 'Failed to save budgets', false);
            }
        }

        async function loadBudgets() {
            try {
                const response = await fetch('/budgets');
                if (!response.ok) throw new Error('Failed to load budgets');
                budgets = await response.json();
                renderBudgets();
            } catch (error) {
                console.error('Error loading budgets:', error);
                budgets = [];
                renderBudgets();
            }
        }

        // --- Import/Export ---
        async function handleCsvImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            const formData = new FormData();
            formData.append('file', file);
            const messageDiv = document.getElementById('importMessage');
            const summaryDiv = document.getElementById('importSummary');

            messageDiv.textContent = 'Importing... this may take a while for large files.';
            messageDiv.className = 'form-message';
            summaryDiv.style.display = 'none';

            try {
                const response = await fetch('/import/csv', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    messageDiv.textContent = 'Import completed!';
                    messageDiv.className = 'form-message success';
                    summaryDiv.style.display = 'block';
                    document.getElementById('summary-processed').textContent = result.total_processed;
                    document.getElementById('summary-imported').textContent = result.imported;
                    document.getElementById('summary-skipped').textContent = result.skipped;
                    document.getElementById('summary-new-categories').textContent = (result.new_categories || []).join(', ') || 'None';
                    
                    await initialize();
                } else {
                    messageDiv.textContent = `Error: ${result.error || 'Failed to import CSV'}`;
                    messageDiv.className = 'form-message error';
                }
            } catch (error) {
                console.error('Error importing CSV:', error);
                messageDiv.textContent = 'Error: An unexpected error occurred during import.';
                messageDiv.className = 'form-message error';
            } finally {
                event.target.value = '';
            }
        }

        // TODO: remove in the future; handles import from EO < v3.20
        async function handleCsvImportOld(event) {
            const file = event.target.files[0];
            if (!file) return;
            const formData = new FormData();
            formData.append('file', file);
            const messageDiv = document.getElementById('importMessage');
            const summaryDiv = document.getElementById('importSummary');

            messageDiv.textContent = 'Importing... this may take a while for large files.';
            messageDiv.className = 'form-message';
            summaryDiv.style.display = 'none';

            try {
                const response = await fetch('/import/csvold', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    messageDiv.textContent = 'Import completed!';
                    messageDiv.className = 'form-message success';
                    summaryDiv.style.display = 'block';
                    document.getElementById('summary-processed').textContent = result.total_processed;
                    document.getElementById('summary-imported').textContent = result.imported;
                    document.getElementById('summary-skipped').textContent = result.skipped;
                    document.getElementById('summary-new-categories').textContent = (result.new_categories || []).join(', ') || 'None';
                    
                    await initialize();
                } else {
                    messageDiv.textContent = `Error: ${result.error || 'Failed to import CSV'}`;
                    messageDiv.className = 'form-message error';
                }
            } catch (error) {
                console.error('Error importing CSV:', error);
                messageDiv.textContent = 'Error: An unexpected error occurred during import.';
                messageDiv.className = 'form-message error';
            } finally {
                event.target.value = '';
            }
        }

        // --- Initialization ---
        async function initialize() {
            try {
                const [configResponse, expensesResponse, recurringExpensesResponse] = await Promise.all([
                    fetch('/config'),
                    fetch('/expenses'),
                    fetch('/recurring-expenses')
                ]);
                if (!configResponse.ok) throw new Error('Failed to fetch configuration');
                const config = await configResponse.json();
                if (!expensesResponse.ok) throw new Error('Failed to fetch expenses');
                const expenses = await expensesResponse.json();
                if (!recurringExpensesResponse.ok) throw new Error('Failed to fetch recurring expenses');
                recurringExpenses = await recurringExpensesResponse.json() || [];

                categories = [...config.categories];
                LOCKED_CATEGORIES.forEach(cat => {
                    if (!categories.includes(cat)) categories.unshift(cat);
                });
                investmentTypes = [...(config.investmentTypes || ['Index', 'Crypto', 'ETF', 'Bonds'])];
                currentCurrency = config.currency;
                currentStartDate = config.startDate;
                allTags.clear();
                (expenses || []).forEach(exp => (exp.tags || []).forEach(tag => allTags.add(tag)));
                (recurringExpenses || []).forEach(exp => (exp.tags || []).forEach(tag => allTags.add(tag)));

                renderCategories();
                renderInvestmentTypes();
                populateCurrencySelect();
                populateStartDateInput();
                document.getElementById('recurringCategory').innerHTML = categories.map(c => `<option value="${c}">${c}</option>`).join('');
                document.getElementById('editRecurringCategory').innerHTML = categories.map(c => `<option value="${c}">${c}</option>`).join('');
                renderRecurringExpenses(recurringExpenses);

                // Load budgets
                await loadBudgets();

                createTagInput('tags-input', 'selected-tags', 'tags-dropdown', addFormSelectedTags);
                fetch('/version').then(r => r.ok ? r.text() : 'dev').then(version => {
                    const link = document.getElementById('version-link');
                    link.textContent = version;
                    if (version !== 'dev') link.href = `https://github.com/tanq16/expenseowl/releases/tag/${version}`;
                }).catch(e => console.error('Failed to fetch version:', e));

            } catch (error) {
                console.error('Failed to initialize settings:', error);
                showMessage('categoriesMessage', 'Failed to load settings', false);
            }
        }
        
        // --- Theme Management ---
        const themeSelect = document.getElementById('themeSelect');
        const currentTheme = localStorage.getItem('theme') || 'system';
        themeSelect.value = currentTheme;
        function applyTheme(theme) {
            if (theme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            } else if (theme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        }
        themeSelect.addEventListener('change', (e) => {
            const selectedTheme = e.target.value;
            localStorage.setItem('theme', selectedTheme);
            applyTheme(selectedTheme);
            showMessage('themeMessage', 'Theme updated successfully.', true);
        });

        // --- Event Listeners ---
        document.getElementById('addCategory').addEventListener('click', addCategory);
        document.getElementById('saveCategories').addEventListener('click', saveCategories);
        document.getElementById('saveBudgets').addEventListener('click', saveBudgets);
        document.getElementById('addInvestmentType').addEventListener('click', addInvestmentType);
        document.getElementById('saveInvestmentTypes').addEventListener('click', saveInvestmentTypes);
        document.getElementById('newInvestmentType').addEventListener('keypress', e => e.key === 'Enter' && addInvestmentType());
        document.getElementById('saveCurrency').addEventListener('click', saveCurrency);
        document.getElementById('saveStartDate').addEventListener('click', saveStartDate);
        document.getElementById('csv-import-file').addEventListener('change', handleCsvImport);
        document.getElementById('csv-import-file-old').addEventListener('change', handleCsvImportOld);
        document.getElementById('newCategory').addEventListener('keypress', e => e.key === 'Enter' && addCategory());

        document.getElementById('recurringExpenseForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const category = document.getElementById('recurringCategory').value;
            const isIncome = category === 'Income';
            let amount = parseFloat(document.getElementById('recurringAmount').value);
            if (!isIncome) amount *= -1;

            const formData = {
                name: document.getElementById('recurringName').value,
                amount: amount,
                category: category,
                tags: Array.from(addFormSelectedTags),
                interval: document.getElementById('recurringInterval').value,
                startDate: getISODateWithLocalTime(document.getElementById('recurringStartDate').value),
                occurrences: parseInt(document.getElementById('recurringOccurrences').value, 10)
            };

            try {
                const response = await fetch('/recurring-expense', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                if (response.ok) {
                    showMessage('recurringExpenseMessage', 'Recurring expense added successfully!', true);
                    document.getElementById('recurringExpenseForm').reset();
                    document.getElementById('selected-tags').innerHTML = '';
                    addFormSelectedTags.clear();
                    fetchAndRenderRecurringExpenses();
                } else {
                    const error = await response.json();
                    showMessage('recurringExpenseMessage', `Error: ${error.error || 'Failed to add recurring expense'}`, false);
                }
            } catch (error) {
                console.error('Error adding recurring expense:', error);
                showMessage('recurringExpenseMessage', 'Error: Failed to add recurring expense', false);
            }
        });

        document.addEventListener('DOMContentLoaded', initialize);

        document.getElementById('toggleRecurringFormBtn').addEventListener('click', function() {
            const formContainer = document.getElementById('addRecurringContainer');
            const isHidden = formContainer.style.display === 'none' || formContainer.style.display === '';

            if (isHidden) {
                formContainer.style.display = 'block';
                this.innerHTML = '<i class="fa-solid fa-times"></i> Close';
                this.classList.remove('btn-primary');
                this.classList.add('btn-secondary');
            } else {
                formContainer.style.display = 'none';
                this.innerHTML = '<i class="fa-solid fa-plus"></i> Add Recurring Transaction';
                this.classList.remove('btn-secondary');
                this.classList.add('btn-primary');
            }
        });

        window.removeCategory = removeCategory;
        window.showRecurringDeleteModal = showRecurringDeleteModal;
        window.closeRecurringDeleteModal = closeRecurringDeleteModal;
        window.confirmRecurringDelete = confirmRecurringDelete;
        window.showRecurringEditModal = showRecurringEditModal;
        window.closeRecurringEditModal = closeRecurringEditModal;
        window.confirmRecurringUpdate = confirmRecurringUpdate;
    </script>
</body>
</html>
